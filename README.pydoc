Help on module lopper:

NAME
    lopper

DESCRIPTION
    #/*
    # * Copyright (c) 2019,2020 Xilinx Inc. All rights reserved.
    # *
    # * Author:
    # *       Bruce Ashfield <bruce.ashfield@xilinx.com>
    # *
    # * SPDX-License-Identifier: BSD-3-Clause
    # */

CLASSES
    builtins.object
        Lop
        LopAssist
        Lopper
        SystemDeviceTree
    enum.Enum(builtins.object)
        LopperAction
        LopperFmt
    
    class Lop(builtins.object)
     |  Internal class to contain the details of a lopper file
     |  
     |  Attributes:
     |     - dts: the dts source file path for a lop
     |     - dtb: the compiled dtb file path for a lop
     |     - fdt: the loaded FDT representation of the dtb
     |  
     |  Methods defined here:
     |  
     |  __init__(self, lop_file)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LopAssist(builtins.object)
     |  Internal class to contain the details of a lopper assist
     |  
     |  Methods defined here:
     |  
     |  __init__(self, lop_file, module='', properties_dict={})
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Lopper(builtins.object)
     |  The Lopper Class contains static methods for manipulating device trees
     |  
     |  Use the lopper methods when manipulating device trees (in particular
     |  libfdt FDT objects) or SystemDeviceTree classes.
     |  
     |  Static methods defined here:
     |  
     |  dt_compile(dts_file, i_files, includes, force_overwrite=False, outdir='./')
     |      Compile a dts file to a dtb
     |      
     |      This routine takes a dts input file, other dts include files,
     |      include search path and then uses standard tools (cpp, dtc, etc).
     |      
     |      Environment variables can be used tweak the execution of the various
     |      tools and stages:
     |      
     |         LOPPER_CPP: set if a different cpp than the standard one should
     |                     be used, or if cpp is not on the path
     |         LOPPER_PPFLAGS: flags to be used when calling cpp
     |         LOPPER_DTC: set if a non standard dtc should be used, or if dtc
     |                     is not on the path
     |         LOPPER_DTC_FLAGS: flags to use when calling dtc
     |         LOPPER_DTC_OFLAGS: extra dtc flags if an overlay is being compiled
     |         LOPPER_DTC_BFLAGS: extra dtc args/flags
     |      
     |      Args:
     |         dts_file (string): path to the dts file to be compiled
     |         i_files (list): files to be included
     |         includes (list): list of include directories (translated into -i <foo>
     |                          for dtc calls)
     |         force_overwrite (bool,optional): should files be overwritten.
     |                                          Default is False
     |      
     |      Returns:
     |         Nothing
     |  
     |  dtb_dts_export(dtb, outfilename='', verbose=0)
     |      writes a dtb to a file or to stdout as a dts
     |      
     |      Args:
     |         dtb: a compiled device tree
     |         outfilename (string): the output filename (stdout is used if empty)
     |         verbose (int,optional): extra debug info. default 0.
     |      
     |      Returns:
     |         The return value of executing dtc to dump the dtb to dts
     |  
     |  encode_byte_array(values)
     |      utility to encode a list of values into a bytearray
     |      
     |      Args:
     |         values (list): integer (numeric) values to encode
     |      
     |      Returns:
     |         byte array: the encoded byte array
     |  
     |  encode_byte_array_from_strings(values)
     |      utility to encode a list of strings into a bytearray
     |      
     |      Args:
     |         values (list): string values to encode
     |      
     |      Returns:
     |         byte array: the encoded byte array
     |  
     |  get_subnodes(fdt, node_path)
     |      Read a list of subnodes from a node
     |      
     |      Args:
     |         node_path: Full path to node, e.g. '/subnode@1/subsubnode'
     |      
     |      Returns:
     |         List of subnode names for that node, e.g. ['subsubnode', 'ss1']
     |  
     |  getphandle(fdt, node_number)
     |      utility command to get a phandle (as a number) from a node
     |      
     |      Args:
     |         fdt (FDT): flattened device tree
     |         node_number (int): node number in the fdt
     |      
     |      Returns:
     |         int: the phandle of the node number, if successful, -1 if not
     |  
     |  input_file_type(infile)
     |      utility to return the "type" of a file, aka the extension
     |      
     |      Args:
     |         infile (string): path of the file
     |      
     |      Returns:
     |         string: the extension of the file
     |  
     |  node_abspath(fdt, nodeid)
     |      Get the absolute (fully specified) path of a nodes
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          nodeid: device tree node offset
     |      
     |      Returns:
     |          string: node path, if successful, otherwise ""
     |  
     |  node_add(fdt_dest, node_full_path, create_parents=True, verbose=0)
     |      Add an empty node to a flattended device tree
     |      
     |      Creates a new node in a flattened devide tree at a given path. If
     |      desired a node structure (aka parents) will be created as part of
     |      adding the node at the specified path.
     |      
     |      Args:
     |          fdt_dest (fdt): flattened device tree object
     |          node_full_path (string): fully specified path (and name) of the node to create
     |          create_parents (bool,optional): Should parent nodes be created. Default is True.
     |              True: create parents as required, False: error if parents are missing
     |          verbose (int,optional): verbosity level. default is 0.
     |      
     |      Returns:
     |          int: The node offset of the created node, if successfull, otherwise -1
     |  
     |  node_by_phandle(fdt, phandle, verbose=0)
     |      Get a node offset by a phandle
     |      
     |      Thin wrapper around the libfdt routine. The wrapper provides
     |      consistent exception handling and verbosity level handling.
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          phandle(int): phandle to use as lookup key
     |          verbose(bool,optional): verbosity level. Deafult is 0.
     |      
     |      Returns:
     |          int: if > 0, the node that was found. -1 if node was not found.
     |  
     |  node_copy(fdt_source, node_source_offset, fdt_dest, node_dest_parent_offset, verbose=0)
     |      Copies a node from one FDT to another
     |      
     |      Copies a node between flattened device trees. The node (and
     |      properties) will be copied to the specified target device tree and
     |      path (ensure that a node does not already exist at the destination
     |      path).
     |      
     |      Note: the destination node parent must exist before calling this routine
     |      
     |      Properties are iterated, decoded and then copied (encoded) to the
     |      destination node. As such, the copies are limited by the
     |      decode/encode capabilities. If properties do not look correct in the
     |      copy, the decode/encode routines need to be checked.
     |      
     |      Args:
     |          fdt_source (fdt): source flattened device tree object
     |          node_source_offset: source device tree node offset
     |          fdt_dest (fdt): destination flattened device tree object
     |          node_dest_parent_offset: destination device parent node
     |          verbose (int,optional): verbosity level. default is 0.
     |      
     |      Returns:
     |          bool: True if the node was copied, otherise, False
     |  
     |  node_copy_from_path(fdt_source, node_source_path, fdt_dest, node_full_dest, verbose=0)
     |      Copies a node from one FDT to another
     |      
     |      Copies a node between flattened device trees. The node (and
     |      properties) will be copied to the specified target device tree and
     |      path (ensure that a node does not already exist at the destination
     |      path).
     |      
     |      This routine is a wrapper around node_copy(), and will create a
     |      parent node structure in the destination fdt as required.
     |      
     |      Args:
     |          fdt_source (fdt): source flattened device tree object
     |          node_source_path: source device tree node path (fully specified)
     |          fdt_dest (fdt): destination flattened device tree object
     |          node_full_dest: destination device tree path for copied node (fully specified)
     |          verbose (int,optional): verbosity level. default is 0.
     |      
     |      Returns:
     |          bool: True if the node was copied, otherise, False
     |  
     |  node_filter(sdt, node_prefix, action, test_cmd, verbose=0)
     |      Filter nodes and perform an action
     |      
     |      Starting from the supplied path (node_prefix), this function walks
     |      the device tree and executes a block of python code to test each
     |      node.
     |      
     |      If the block of code (test_cmd) returns True, then the action is
     |      taken. If false, nothing is done.
     |      
     |      Currently defined actions:
     |      
     |         - delete: delete the node
     |         - report: (not currently implemented)
     |         - whitelist: (not currently implemented)
     |         - blacklist: (not currently implemented)
     |      
     |      The "test_cmd" python code, runs in a constructed/safe environment to
     |      ensure that the code won't cause harmful sideffects to the execution
     |      environment.
     |      
     |      The following functions and variables are currently available in the
     |      safe_dict:
     |      
     |          len
     |          print
     |          Lopper.prop_get
     |          Lopper.getphandle
     |          Lopper.node_filter
     |          Lopper.refcount
     |          fdt
     |          sdt
     |          verbose
     |      
     |      When executing in the filter context (aka node walking), the following
     |      variables are available to the python code block.
     |      
     |          fdt  : the flattened device tree being processed
     |          sdt  : the system device tree
     |          node : the node number
     |          node_name : the name of the node (as defined by the dts/dtb)
     |      
     |      A standard python "return True" and "return False" should be used to
     |      indicate the result of the test.
     |      
     |      Args:
     |          sdt (SystemDeviceTree): system device tree to filter
     |          node_prefix (string): starting node path
     |          action (LopperAction): action to take in the True condition
     |          test_cmd (string): block of python code to test against each node
     |          verbose (int,optional): verbosity level to use.
     |      
     |      Returns:
     |          Nothing
     |  
     |  node_find(fdt, node_prefix)
     |      Finds a node by its prefix
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          node_prefix (string): device tree path
     |      
     |      Returns:
     |          int: node number if successful, otherwise -1
     |  
     |  node_find_by_name(fdt, node_name, starting_node=0, multi_match=False)
     |      Finds a node by its name (not path)
     |      
     |      Searches for a node by its name, and returns the offset of that same node
     |      Note: use this when you don't know the full path of a node
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          node_name (string): name of the node
     |          starting_node (int): node number to use as the search starting point
     |          multi_match (bool,optional): flag to indicate if more than one matching
     |                                       node should be found, default is False
     |      
     |      Returns:
     |          tuple: first matching node, list of matching nodes. -1 and [] if no match is found
     |  
     |  node_find_by_regex(fdt, node_regex, starting_node=0, multi_match=False)
     |      Finds a node by a regex /path/<regex>/<name>
     |      
     |      Searches for nodes that match a regex (path + name).
     |      
     |      Note: if you pass the name of a node as the regex, you'll get a list of
     |            that node + children
     |      Note: if you pass no regex, you'll get all nodes from the starting point
     |            to the end of the tree.
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          node_regex (string): regex to use for comparision
     |          starting_node (int): node number to use as the search starting point
     |          multi_match (bool,optional): flag to indicate if more than one matching
     |                                       node should be found, default is False
     |      
     |      Returns:
     |          tuple: first matching node, list of matching nodes. -1 and [] if no match is found
     |  
     |  node_parent_type(fdt, node_name='', node_offset=0)
     |      Get the type of a node's parent
     |      
     |      Uses either the node_name or node_offset to find the type of a
     |      parent node. This is used to discover if node's parent is of a
     |      particular type (i.e. simple_bus) and use it as a trigger for
     |      special processing. 
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          node_name (string): name of the node
     |          node_offset (int): node number / offset
     |      
     |      Returns:
     |          string: type of the parent node if successful, otherwise ''
     |  
     |  node_print(fdt, node_path, children=False, phandle_map={}, verbose=0, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)
     |      Pretty print the details of a node
     |      
     |      print the contents of a node.
     |      
     |      Args:
     |          fdt (FDT): flattened device tree
     |          node_path (string): starting node path
     |          children (bool,optional): True if children should be printed, False if just the node
     |               default is False
     |          phandle_map (dict,optional): dictionary of phandles -> symbols
     |          verbose (int,optional): verbosity level to use.
     |      
     |      Returns:
     |          Nothing
     |  
     |  node_prop_check(fdt, node_name, property_name)
     |      Check if a node contains a property
     |      
     |      Boolean check to see if a node contains a property.
     |      
     |      The node name does not need to be a full path or path prefix, since
     |      the node will be searched starting at the root node, which means that
     |      a non-unique node name could match multiple nodes.
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          node_name (string): name of the node
     |          property_name (string): name of the property to check
     |      
     |      Returns:
     |          bool: True if the node has the property, otherwise False
     |  
     |  node_properties_as_dict(fdt, node, verbose=0)
     |      Create a dictionary populated with the nodes properties.
     |      
     |      Builds a dictionary that is propulated with a node's properties as
     |      the keys, and their values. Used as a utility routine to avoid
     |      multiple calls to check if a property exists, and then to fetch its
     |      value.
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          node (int or string): either a node number or node path
     |          verbose (int,optional): verbosity level. default is 0.
     |      
     |      Returns:
     |          dict: dictionary of the properties, if successfull, otherwise and empty dict
     |  
     |  node_remove_if_not_compatible(fdt, node_prefix, compat_string)
     |      Remove a node if incompatible with passed string
     |      
     |      Utility/cleanup function to remove all nodues under a node_prefix
     |      that are not compatible with a given string.
     |      
     |      Args:
     |          fdt (FDT): flattened device tree
     |          node_prefix (string): starting node path
     |          compat_strin (string): string for compat property comparison
     |      
     |      Returns:
     |          Nothing
     |  
     |  node_type(fdt, node_offset, verbose=0)
     |      Utility function to get the "type" of a node
     |      
     |      A small wrapper around the compatible property, but we can use this
     |      instead of directly getting compatible, since if we switch formats or if
     |      we want to infer anything based on the name of a node, we can hide it in
     |      this routine
     |      
     |      Args:
     |          fdt (fdt): flattened device tree object
     |          node_offset (int): node number
     |          verbose (int): verbose output level
     |      
     |      Returns:
     |          string: compatible string of the node if successful, otherwise ''
     |  
     |  node_walk(fdt, verbose=0)
     |      Walk nodes and gather a list
     |      
     |      Utility / reference routine for gathering a list of nodes.
     |      Always starts at node 0.
     |      
     |      Args:
     |          fdt (FDT): flattened device tree
     |          verbose (int,optional): verbosity level, default 0.
     |      
     |      Returns:
     |          List of nodes. Each containg the [node number, name, phandle, depth]
     |  
     |  nodes_with_property(fdt, match_propname, match_regex='', start_path='/', include_children=True)
     |      Get a list of nodes with a particular property
     |      
     |      Searches a device tree and returns a list of nodes that contain
     |      a given property.
     |      
     |      Matching is done by the existence of a property name in a node.
     |      
     |      If a match_regex is passed, then the value of the property is
     |      tested against the regex. If there's a match, then the node is
     |      added to the list.
     |      
     |      Args:
     |          fdt (fdt): source flattened device tree to search
     |          match_propname (string): target property name
     |          match_regex (string,optional): property value match regex. Default is ""
     |          start_path (string,optional): starting path in the device tree. Default is "/"
     |          include_children (bool,optional): should child nodes be searched. Default is True.
     |      
     |      Returns:
     |          list: list of matching nodes if successful, otherwise an empty list
     |  
     |  prop_get(fdt, node_number, prop_name, ftype=<LopperFmt.SIMPLE: 1>, encode=<LopperFmt.DEC: 4>)
     |      utility command to get a property (as a string) from a node
     |      
     |      A more robust way to get the value of a property in a node, when
     |      you aren't sure of the format of that property. This routine takes
     |      hints when getting the property in the form of a "format type" and
     |      an encoding.
     |      
     |      The format and encoding options are in the following enum type:
     |      
     |         class LopperFmt(Enum):
     |            SIMPLE = 1 (format)
     |            COMPOUND = 2 (format)
     |            HEX = 3 (encoding)
     |            DEC = 4 (encoding)
     |            STRING = 5 (encoding)
     |            MULTI_STRING = 5 (encoding)
     |      
     |      Args:
     |         fdt (FDT): flattened device tree
     |         node_number (int): node number in the fdt
     |         property (string): property name whose value to get
     |         ftype (LopperFmt,optional): format of the property. Default SIMPLE.
     |         encode (LopperFmt,optional); encoding of the property. Default DEC
     |      
     |      Returns:
     |         string: if format is SIMPLE: string value of the property, or "" if not found
     |         list: if format is COMPOUND: list of property values as strings, [] if not found
     |  
     |  prop_set(fdt, node_number, prop_name, prop_val, ftype=<LopperFmt.SIMPLE: 1>)
     |      utility command to set a property in a node
     |      
     |      A more robust way to set the value of a property in a node, This routine
     |      takes hints when getting the property in the form of a "format type"
     |      
     |      The format options are in the following enum type:
     |      
     |         class LopperFmt(Enum):
     |            SIMPLE = 1 (format)
     |            COMPOUND = 2 (format)
     |      
     |      Based on the format hint, and the passed value, the property is encoded
     |      into a byte array and stored into the flattened device tree node.
     |      
     |      Args:
     |         fdt_dst (FDT): flattened device tree
     |         node_number (int): node number in the fdt
     |         prop_name (string): property name whose value to set
     |         ftype (LopperFmt,optional): format of the property. Default SIMPLE.
     |      
     |      Returns:
     |         Nothing
     |  
     |  property_list(fdt, node_path)
     |      Read a list of properties from a node
     |      
     |      Args:
     |         node_path: Full path to node, e.g. '/subnode@1/subsubnode'
     |      
     |      Returns:
     |         List of property names for that node, e.g. ['compatible', 'reg']
     |  
     |  property_value_decode(property, poffset, ftype=<LopperFmt.SIMPLE: 1>, encode=<LopperFmt.DEC: 4>, verbose=0)
     |      Decodes a property
     |      
     |      Decode a property into a common data type (string, integer, list of
     |      strings, etc).
     |      
     |      This is a robust wrapper around the decode facilities provided via
     |      libfdt. This routine tries multiple encode formats and uses
     |      heuristics to determine the best format for the decoded property.
     |      
     |      The format type (ftype) and encod arguments can be used to help
     |      decode properly when the type of a property is known.
     |      
     |      The format and encoding options are in the following enum type:
     |      
     |         class LopperFmt(Enum):
     |            SIMPLE = 1 (format)
     |            COMPOUND = 2 (format)
     |            HEX = 3 (encoding)
     |            DEC = 4 (encoding)
     |            STRING = 5 (encoding)
     |            MULTI_STRING = 5 (encoding)
     |      
     |      Args:
     |         property (libfdt property): property to decode
     |         poffset (int): offset of the property in the node (unused)
     |         ftype (LopperFmt,optional): format hint for the property. default is SIMPLE
     |         encode (LopperFmt,optional): encoding hint. default is DEC
     |         verbose (int,optional): verbosity level, default is 0
     |      
     |      Returns:
     |         (string): if SIMPLE. The property as a string
     |         (list): if COMPOUND. The property as a list of strings / values
     |  
     |  read_phandle_map(phandle_file, verbose=0)
     |      read an exported phandle map into memory
     |      
     |      reads a CSV formatted file of "phandle number" , "symbolic_name" into a
     |      dictionary
     |      
     |      Args:
     |          phandle_file (string): path to the phandle file
     |          verbose(bool,optional): whether or not verbose logging should be done
     |      
     |      Returns:
     |          dict: keys are the numeric phandle, values are the symbolic equivalent
     |  
     |  refcount(sdt, nodename)
     |      return the refcount for a given node
     |      
     |      When refcounting is enabled, this routine returns how many references
     |      there have been to a given nodename.
     |      
     |      This is a wrapper around the SystemDeviceTree function of the same
     |      name.
     |      
     |      Args:
     |         sdt (SystemDeviceTree): sdt that is refcounting
     |         nodename (sring): name of the node
     |      
     |      Returns:
     |         (int): the reference count >= 0
     |  
     |  write_fdt(fdt_to_write, output_filename, sdt=None, overwrite=True, verbose=0, pretty=False)
     |      Write a system device tree to a file
     |      
     |      Write a fdt (or system device tree) to an output file. This routine uses
     |      the output filename to determine if a module should be used to write the
     |      output.
     |      
     |      If the output format is .dts or .dtb, Lopper takes care of writing the
     |      output. If it is an unrecognized output type, the available assist
     |      modules are queried for compatibility. If there is a compatible assist,
     |      it is called to write the file, otherwise, a warning or error is raised.
     |      
     |      Args:
     |          fdt_to_write (fdt): source flattened device tree to write
     |          output_filename (string): name of the output file to create
     |          sdt (SystemDeviceTree,optional): system device tree to use for output modules.
     |                 None means don't use a system device tree for module loading.
     |          overwrite (bool,optional): Should existing files be overwritten. Default is True.
     |          verbose (int,optional): verbosity level to use.
     |          pretty(bool,optional): whether pretty printing should be performed. Default is False
     |      
     |      Returns:
     |          Nothing
     |  
     |  write_phandle_map(fdt_to_write, output_filename, verbose=0)
     |      write a phandle map file
     |      
     |      creates a CSV formatted file of "phandle number" , "symbolic_name". This
     |      can be later used to match hex values to symbolic phandles
     |      
     |      Args:
     |          fdt_to_write (FDT): the flattened device tree to process
     |          output_filename (string): path to the phandle file
     |          verbose(bool,optional): whether or not verbose logging should be done
     |      
     |      Returns:
     |          dict: keys are the numeric phandle, values are the symbolic equivalent
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class LopperAction(enum.Enum)
     |  Enum class to define the actions available in Lopper's node_filter function
     |  
     |  Method resolution order:
     |      LopperAction
     |      enum.Enum
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  BLACKLIST = <LopperAction.BLACKLIST: 4>
     |  
     |  DELETE = <LopperAction.DELETE: 1>
     |  
     |  REPORT = <LopperAction.REPORT: 2>
     |  
     |  WHITELIST = <LopperAction.WHITELIST: 3>
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from enum.Enum:
     |  
     |  name
     |      The name of the Enum member.
     |  
     |  value
     |      The value of the Enum member.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from enum.EnumMeta:
     |  
     |  __members__
     |      Returns a mapping of member name->value.
     |      
     |      This mapping lists all enum members, including aliases. Note that this
     |      is a read-only view of the internal mapping.
    
    class LopperFmt(enum.Enum)
     |  Enum class to define the types and encodings of Lopper format routines
     |  
     |  Method resolution order:
     |      LopperFmt
     |      enum.Enum
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  COMPOUND = <LopperFmt.COMPOUND: 2>
     |  
     |  DEC = <LopperFmt.DEC: 4>
     |  
     |  HEX = <LopperFmt.HEX: 3>
     |  
     |  MULTI_STRING = <LopperFmt.MULTI_STRING: 6>
     |  
     |  SIMPLE = <LopperFmt.SIMPLE: 1>
     |  
     |  STRING = <LopperFmt.STRING: 5>
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from enum.Enum:
     |  
     |  name
     |      The name of the Enum member.
     |  
     |  value
     |      The value of the Enum member.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from enum.EnumMeta:
     |  
     |  __members__
     |      Returns a mapping of member name->value.
     |      
     |      This mapping lists all enum members, including aliases. Note that this
     |      is a read-only view of the internal mapping.
    
    class SystemDeviceTree(builtins.object)
     |  The SystemDeviceTree Class represents and manages the full system DTS file
     |  
     |  In particular this class:
     |    - wraps a dts/dtb/fdt containing a system description
     |    - manages and applies operations to the tree
     |    - calls modules and assist functions for processing of that tree
     |  
     |  Attributes:
     |    - dts (string): the source device tree file
     |    - dtb (blob): the compiled dts
     |    - FDT (fdt): the primary flattened device tree represention of the dts
     |    - lops (list): list of loaded lopper operations
     |    - verbose (int): the verbosity level of operations
     |    - node_access (dict): ref count / tracker of device tree nodes
     |    - dry_run (bool): whether or not changes should be written to disk
     |    - output_file (string): default output file for writing
     |  
     |  Methods defined here:
     |  
     |  __init__(self, sdt_file)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  cleanup(self)
     |      cleanup any temporary or copied files
     |      
     |      Either called directly, or registered as an atexit handler. Any
     |      temporary or copied files are removed, as well as other relevant
     |      cleanup.
     |      
     |      Args:
     |         None
     |      
     |      Returns:
     |         Nothing
     |  
     |  domain_spec(self, tgt_domain)
     |      generate a lop for a command line passed domain
     |      
     |      When a target domain is passed on the command line, we must generate
     |      a lop dtb for it, so that it can be processed along with other
     |      operations
     |      
     |      Args:
     |         tgt_domain (string): path to the node to use as the domain
     |      
     |      Returns:
     |         Nothing
     |  
     |  find_compatible_assist(self, cb_node=0, cb_id='', mask='')
     |      Finds a registered assist that is compatible with a given ID
     |      
     |      Searches the registered assists for one that is compatible with an ID.
     |      
     |      The is_compat() routine is called for each registered module. If an
     |      assist is capabable of handling a given ID, it returns True and
     |      associated actions can then be taken.
     |      
     |      I addition to an ID string, a mask can optionally be provided to this
     |      routine. Any assists that have registered a mask, will have that
     |      checked, before calling the is_compat() routine. This allows assists to
     |      be generically registered, but filtered by the caller rather than only
     |      their is_compat() routines.
     |      
     |      Args:
     |          cb_node (int,optional): node offset to be tested. Default is 0 (root)
     |          cb_id (string,optional): ID to be tested for compatibility. Default is ""
     |          mask (string,optional): caller mask for filtering nodes. Default is ""
     |      
     |      Returns:
     |          function reference: the callback routine, or "", if no compatible routine found
     |  
     |  inaccessible_nodes(self, propname)
     |      searches for a property, and optionally removes it
     |      
     |      Treewide operation to locate and remove inaccessible nodes
     |      
     |      Note: not currently called, and is depreciated. Will be removed in the future.
     |      
     |      Args:
     |          propname (string): name of the property to find
     |      
     |      Returns:
     |          Nothing
     |  
     |  load_assists(self)
     |      load assists that have been added to the device tree
     |      
     |      Wraps any command line assists that have been added to the system
     |      device tree. A standard lop format dtb is generated for any found
     |      assists, such that they will be loaded in the same manner as
     |      assists passed directly in lop files.
     |      
     |      Note: this is for internal use only
     |      
     |      Args:
     |         None
     |      
     |      Returns:
     |         Nothing
     |  
     |  node_abspath(self, tgt_node)
     |      Get the absolute (fully specified) path of a node
     |      
     |      Wrapper around the Lopper routine of the same name, to abstract the
     |      FDT that is part of the SystemDeviceTree class.
     |  
     |  node_find(self, node_prefix)
     |      Finds a node by its prefix
     |      
     |      Wrapper around the Lopper routine of the same name, to abstract the
     |      FDT that is part of the SystemDeviceTree class.
     |  
     |  node_find_by_name(self, node_name, starting_node=0)
     |      Finds a node by its name (not path)
     |      
     |      Wrapper around the Lopper routine of the same name, to abstract the
     |      FDT that is part of the SystemDeviceTree class.
     |  
     |  node_properties_as_dict(self, node, verbose=0)
     |      Create a dictionary populated with the nodes properties.
     |      
     |      Wrapper around the Lopper routine of the same name, to abstract the
     |      FDT that is part of the SystemDeviceTree class.
     |  
     |  node_ref(self, node_name)
     |      get the refcount for a node
     |      
     |      When refcounting is enabled, this routine returns the count for a given
     |      node
     |      
     |      We use the name, rather than the offset, since the offset can change if
     |      something is deleted from the tree. But we need to use the full path so
     |      we can find it later.
     |      
     |      Args:
     |         node_name (string): full path to the node to refcount
     |      
     |      Returns:
     |         int: refcount if a node is being tracked, otherwise, -1
     |  
     |  node_ref_inc(self, node_name, parent=False)
     |      increment the refcount for a node
     |      
     |      When refcounting is enabled, this routine increments the count for
     |      a given node name.
     |      
     |      We use the name, rather than the offset, since the offset can change if
     |      something is deleted from the tree. But we need to use the full path so
     |      we can find it later.
     |      
     |      Args:
     |         node_name (string): path to the node to refcount
     |         parent (bool): wether parent references should be incremented. Default False.
     |      
     |      Returns:
     |         Nothing
     |  
     |  node_ref_reset(self, node_name, verbose=0)
     |      reset the refcount for a node
     |      
     |      When refcounting is enabled, this routine resets the refcount for a
     |      given node.
     |      
     |      We use the name, rather than the offset, since the offset can change if
     |      something is deleted from the tree. But we need to use the full path so
     |      we can find it later.
     |      
     |      if no name is passed, all refcounts are reset
     |      
     |      Args:
     |         node_name (string): path to the node to refcount
     |         verbose (bool): flag indicating verbosity. default is 0
     |      
     |      Returns:
     |         Nothing
     |  
     |  node_remove(self, target_node_offset)
     |      remove a node from the device tree
     |      
     |      Thin wrapper and consistent logging around libfdt's node delete.
     |      
     |      Args:
     |         target_node_offset (int): offset of the node to be deleted
     |      
     |      Returns:
     |         Nothing
     |  
     |  node_type(self, node_offset, verbose=0)
     |  
     |  nodes_refd(self)
     |      Get a list of refererenced nodes
     |      
     |      When refcounting is enabled, this routine returns the list of nodes
     |      that have been referenced.
     |      
     |      We use the name, rather than the offset, since the offset can change if
     |      something is deleted from the tree. But we need to use the full path so
     |      we can find it later.
     |      
     |      Args:
     |         None
     |      
     |      Returns:
     |         list (strings): list of referenced nodes, or [] if there are no referenced nodes
     |  
     |  perform_lops(self)
     |      Execute all loaded lops
     |      
     |      Iterates and executes all the loaded lopper operations (lops) for the
     |      System Device tree.
     |      
     |      The lops are processed in priority order (priority specified at the file
     |      level), and the rules processed in order as they appear in the lop file.
     |      
     |      lopper operations can immediately process the output of the previous
     |      operation and hence can be stacked to perform complex operations.
     |      
     |      Args:
     |          None
     |      
     |      Returns:
     |          Nothing
     |  
     |  property_find(self, prop_name, remove=False)
     |      searches for a property, and optionally removes it
     |      
     |      Treewide operation to find and possibly delete a property.
     |      
     |      Note: not currently called, and is depreciated. Will be removed in the future
     |      
     |      Args:
     |          prop_name (string): name of the property to find
     |          remove (bool,optional): flag to indicate whether or not the property should be removed.
     |                                  Default is False
     |      Returns:
     |          Nothing
     |  
     |  property_get(self, node_number, prop_name, ftype=<LopperFmt.SIMPLE: 1>, encode=<LopperFmt.DEC: 4>)
     |      utility command to get a property (as a string) from a node
     |      
     |      Wrapper around the Lopper static routine of the same name.
     |  
     |  property_modify(self, node_prefix='/', prop_name='', propval='', node_regex='', add_if_missing=False)
     |      modifies a property in a node
     |      
     |      Modifies a property (if it exists) in a node (and optionally its children).
     |      
     |      Args:
     |          node_prefix (string,optional): starting node prefix. Default is "/"
     |          prop_name (string,optional): name of property to modify. Default is ""
     |          prop_val (string,optional): new value of the property. Default is ""
     |          node_regex (string,optional): if non-zero, the node regex indicates if child nodes should be checked. Default is ""
     |          add_if_missing (bool,optional): create the property if it is missing (i.e. a property add).
     |                                          Default is False.
     |      
     |      Returns:
     |          Nothing
     |  
     |  property_remove(self, node_prefix='/', prop_name='', recursive=True)
     |      removes a property from a node
     |      
     |      Removes a property (if it exists) from a node (and optionally its children).
     |      
     |      Args:
     |          node_prefix (string,optional): starting node prefix. Default is "/"
     |          prop_name (string,optional): name of property to remove. Default is ""
     |          recursive (bool,optional): flag to indicate if children should be processed. Default is True
     |      
     |      Returns:
     |          Nothing
     |  
     |  property_set(self, node_number, prop_name, prop_val, ftype=<LopperFmt.SIMPLE: 1>)
     |      utility command to set a property in a node
     |      
     |      Wrapper around the Lopper static method of the same name.
     |  
     |  setup(self, sdt_file, input_files, include_paths, assists=[], force=False)
     |      executes setup and initialization tasks for a system device tree
     |      
     |      setup validates the inputs, and calls the appropriate routines to
     |      preprocess and compile passed input files (.dts).
     |      
     |      Args:
     |         sdt_file (String): system device tree path/file
     |         input_files (list): list of input files (.dts, or .dtb) in addition to the sdt_file
     |         include_paths (list): list of paths to search for files
     |         assists (list,optional): list of python assist modules to load. Default is []
     |         force (bool,optional): flag indicating if files should be overwritten and compilation
     |                                forced. Default is False.
     |      
     |      Returns:
     |         Nothing
     |  
     |  write(self, outfilename)
     |      write the system device tree to a file
     |      
     |      Writes the system device tree (modified or not) to the passed
     |      output file name
     |      
     |      Args:
     |         outfilename (string): output file name
     |      
     |      Returns:
     |         Nothing
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    at_exit_cleanup()
    
    main()
    
    stdoutIO(stdout=None)
    
    usage()

DATA
    LOPPER_VERSION = '2020.2-alpha'
    MAX_RETRIES = 3
    QUIET_ALL = range(1, 18)
    QUIET_NOTFOUND = (1,)
    lopper_directory = '/home/bruce/git/system-device-tree'

FILE
    /home/bruce/git/system-device-tree/lopper.py


